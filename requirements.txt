# Fabric CLI CI/CD - Thin Wrapper
# Based on learnings from 1,830 LOC → 270 LOC optimization



















































































































































































































































    }        "AZURE_SUBSCRIPTION_ID": secrets.subscription_id or "",        "AZURE_DEVOPS_PAT": secrets.azure_devops_pat or "",        "GITHUB_TOKEN": secrets.github_token or "",        "AZURE_TENANT_ID": secrets.azure_tenant_id or "",        "TENANT_ID": secrets.get_tenant_id(),        "AZURE_CLIENT_SECRET": secrets.azure_client_secret or "",        "AZURE_CLIENT_ID": secrets.azure_client_id or "",        "FABRIC_TOKEN": secrets.fabric_token or "",    return {        secrets = FabricSecrets.load_with_fallback()    """    internally using the new secrets management system.    This maintains compatibility with the existing codebase while        Returns dict of environment variables for existing code.    Legacy function for backward compatibility.    """def get_environment_variables() -> dict:# Backward compatibility with existing code    return secrets            raise ValueError(error_msg)    if not is_valid:    is_valid, error_msg = secrets.validate_fabric_auth()    # Validate Fabric authentication        secrets = FabricSecrets.load_with_fallback(env_file)    """        ValueError: If required credentials are missing    Raises:                FabricSecrets instance    Returns:                env_file: Optional path to .env file    Args:        Convenience function to load secrets with validation.    """def get_secrets(env_file: Optional[Path] = None) -> FabricSecrets:        return config                    logger.debug(f"Loaded AZURE_CLIENT_ID from {source}")            source = "environment variable" if os.getenv("AZURE_CLIENT_ID") else ".env file"        if config.azure_client_id:        # Log configuration source (without exposing secrets)                    config = cls()        else:            config = cls(_env_file=str(env_file))        if env_file:        # Load configuration                    logger.info("Running locally - loading from environment variables with .env fallback")        else:            logger.info("Running in CI/CD environment - loading from environment variables")        if is_ci:                ])            os.getenv("JENKINS_URL")            os.getenv("GITLAB_CI"),            os.getenv("AZURE_PIPELINES"),            os.getenv("GITHUB_ACTIONS"),            os.getenv("CI"),        is_ci = any([        # Check if we're running in CI/CD (common CI env vars)        """            FabricSecrets instance        Returns:                    env_file: Optional path to .env file (defaults to .env in current directory)        Args:                3. Log the source of configuration        2. Fall back to .env file        1. Try environment variables first        This method demonstrates the waterfall pattern:                Load secrets with explicit fallback logic.        """    def load_with_fallback(cls, env_file: Optional[Path] = None) -> "FabricSecrets":    @classmethod            return False, f"Unknown Git provider: {provider}"                    )                "or add it to your .env file."                "Missing Azure DevOps authentication. Set AZURE_DEVOPS_PAT environment variable "            return False, (                return True, ""            if self.azure_devops_pat:        elif provider.lower() in ["azure_devops", "azuredevops", "ado"]:                    )                "or add it to your .env file."                "Missing GitHub authentication. Set GITHUB_TOKEN environment variable "            return False, (                return True, ""            if self.github_token:        if provider.lower() == "github":        """            (is_valid, error_message)        Returns:                        provider: 'github' or 'azure_devops'        Args:                Validate Git authentication credentials.        """    def validate_git_auth(self, provider: str = "github") -> tuple[bool, str]:            return False, error_msg        )            "For local dev: Add them to your .env file."            "For CI/CD: Set these as secrets in your pipeline.\n"            "  2. Direct token: FABRIC_TOKEN\n\n"            "  1. Service Principal: AZURE_CLIENT_ID, AZURE_CLIENT_SECRET, TENANT_ID\n"            "Missing Fabric authentication credentials. Please provide either:\n"        error_msg = (        # No valid credentials found                    return True, ""        if self.fabric_token:        # Check for direct token                    return True, ""        if self.azure_client_id and self.azure_client_secret and self.get_tenant_id():        # Check for Service Principal credentials        """            (is_valid, error_message)        Returns:                Validate that we have sufficient credentials for Fabric authentication.        """    def validate_fabric_auth(self) -> tuple[bool, str]:            return self.tenant_id or self.azure_tenant_id or ""        """Get tenant ID with fallback logic"""    def get_tenant_id(self) -> str:            return info.data.get("azure_tenant_id")        # Fall back to azure_tenant_id if tenant_id not set            return v        if v:        """Normalize tenant_id from either TENANT_ID or AZURE_TENANT_ID"""    def normalize_tenant_id(cls, v, info):    @classmethod    @field_validator("tenant_id", mode="before")        )        description="Azure Subscription ID"        alias="AZURE_SUBSCRIPTION_ID",        default=None,    subscription_id: Optional[str] = Field(    # Configuration        )        description="Azure DevOps Personal Access Token"        alias="AZURE_DEVOPS_PAT",        default=None,    azure_devops_pat: Optional[str] = Field(        )        description="GitHub Personal Access Token"        alias="GITHUB_TOKEN",        default=None,    github_token: Optional[str] = Field(    # Git Credentials        )        description="Azure Tenant ID (alternate naming)"        alias="AZURE_TENANT_ID",        default=None,    azure_tenant_id: Optional[str] = Field(        )        description="Azure Tenant ID"        alias="TENANT_ID",        default=None,    tenant_id: Optional[str] = Field(        )        description="Azure Service Principal Client Secret"        alias="AZURE_CLIENT_SECRET",        default=None,    azure_client_secret: Optional[str] = Field(        )        description="Azure Service Principal Client ID"        alias="AZURE_CLIENT_ID",        default=None,    azure_client_id: Optional[str] = Field(    # Service Principal Credentials        )        description="Fabric API token (usually from Service Principal)"        default=None,    fabric_token: Optional[str] = Field(    # Fabric Authentication        )        extra="ignore"        case_sensitive=False,        env_file_encoding="utf-8",        env_file=".env",    model_config = SettingsConfigDict(        """    3. Error if neither exists    2. .env file (local development)    1. Environment variables (CI/CD pipelines inject these)    Priority Order:        Fabric authentication secrets with waterfall loading pattern.    """class FabricSecrets(BaseSettings):logger = logging.getLogger(__name__)from pydantic_settings import BaseSettings, SettingsConfigDictfrom pydantic import Field, field_validatorfrom typing import Optionalfrom pathlib import Pathimport osimport logging"""- Clear error messages for missing credentials- Type-safe configuration using pydantic-settings- Works seamlessly in local dev and CI/CD pipelines- Priority loading: OS Environment Variables → .env file → ErrorKey Features:Implements the 12-Factor App configuration pattern
python-dotenv>=1.0.0
pyyaml>=6.0
requests>=2.31.0
jsonschema>=4.19.0
click>=8.1.0
rich>=13.0.0
typer>=0.9.0
gitpython>=3.1.0
azure-identity>=1.15.0
azure-storage-blob>=12.19.0

# Gap closing enhancements
pydantic>=2.5.0
pydantic-settings>=2.1.0
jinja2>=3.1.2
packaging>=23.0

# Development dependencies
pytest>=7.4.0
pytest-cov>=4.1.0
black>=23.0.0
flake8>=6.0.0
mypy>=1.5.0

# Microsoft Fabric CLI (Install directly from GitHub to ensure correct tool)
git+https://github.com/microsoft/fabric-cli.git@main#egg=ms-fabric-cli