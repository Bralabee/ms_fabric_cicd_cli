Metadata-Version: 2.4
Name: usf-fabric-cli
Version: 1.1.0
Summary: CLI tool for Microsoft Fabric CI/CD automation
Author-email: Sanmi Ibitoye <sanmi.ibitoye@leit.ltd>
License: MIT
Requires-Python: >=3.9
Description-Content-Type: text/markdown
Requires-Dist: typer>=0.9.0
Requires-Dist: rich>=13.0.0
Requires-Dist: pyyaml>=6.0
Requires-Dist: python-dotenv>=1.0.0
Requires-Dist: jsonschema>=4.19.0
Requires-Dist: azure-identity>=1.15.0
Requires-Dist: azure-keyvault-secrets>=4.7.0
Requires-Dist: requests>=2.31.0
Requires-Dist: gitpython>=3.1.0
Requires-Dist: azure-storage-blob>=12.19.0
Requires-Dist: pydantic>=2.5.0
Requires-Dist: pydantic-settings>=2.1.0
Requires-Dist: jinja2>=3.1.2
Requires-Dist: packaging>=23.0

# Fabric CLI CI/CD - Enterprise Deployment Framework

Enterprise-grade Microsoft Fabric deployment automation leveraging the official Fabric CLI with 12-Factor App configuration management, Jinja2 artifact templating, and REST API Git integration. Designed for organization-agnostic operation with 85% code reduction from traditional enterprise frameworks.

## Core Capabilities

- **Automated Deployment**: Idempotent workspace provisioning with intelligent state management
- **Secret Management**: 12-Factor App compliant credential handling (Environment Variables → .env fallback → Azure Key Vault)
- **Artifact Templating**: Jinja2 engine for environment-specific artifact transformation
- **Git Integration**: REST API-driven repository connections for Azure DevOps and GitHub
- **Audit Compliance**: Structured JSONL logging for regulatory requirements
- **Branch Isolation**: Feature branch workspaces for parallel development workflows  

## Architecture

```
┌─────────────────────────────────────┐
│   Configuration Layer              │  (YAML-driven)
└────────────┬────────────────────────┘
             │
    ┌────────┴────────────┐
    │                     │
┌───▼─────────────┐  ┌───▼──────────────────┐
│  Fabric CLI     │  │ Thin Wrapper         │
│  (90% of work)  │  │ (~270 LOC)           │
└─────────────────┘  └──────────────────────┘
```

## Quick Start

### 1. Environment Setup

```bash
# Create and activate conda environment
conda env create -f environment.yml
conda activate fabric-cli-cicd

# Verify Fabric CLI installation and dependencies
python scripts/preflight_check.py --auto-install

# Configure authentication credentials
cp .env.template .env
# Edit .env with Service Principal credentials:
#   AZURE_CLIENT_ID       - Service Principal application ID
#   AZURE_CLIENT_SECRET   - Service Principal secret value
#   AZURE_TENANT_ID       - Azure AD tenant identifier
#   FABRIC_TOKEN          - Direct token (optional, auto-generated from SP)
#   AZURE_KEYVAULT_URL    - Azure Key Vault URL (optional, for production)

### 2. Azure DevOps Integration (Prerequisites)

If using Azure DevOps with a Service Principal, ensure the following:

1.  **Service Principal Access Level**: The Service Principal must have **Basic** access level in Azure DevOps Organization Settings -> Users.
2.  **Project Permissions**: The Service Principal must be added to the **Contributors** group of the target Azure DevOps Project.
3.  **Fabric Tenant Settings**: Enable "Service principals can use Fabric APIs" and "Service principals can create workspaces" in Fabric Admin Portal.
4.  **Workspace Admin**: The Service Principal must be assigned the **Admin** role in the workspace configuration (`project.yaml`).

### 3. Configure Your Project
```

### 3. End-to-End Workflow (From Scratch)

Follow these steps to deploy a new project from scratch:

**Step 1: Generate Project Configuration**
Use the template generator to create a standardized configuration file.
```bash
python scripts/generate_project.py "Contoso Inc" "Finance Analytics" --template basic_etl
# Output: config/projects/contoso_inc/finance_analytics.yaml
```

**Step 2: Initialize Azure DevOps Repository**
Create the backing Git repository for your new project.
```bash
python scripts/utilities/init_ado_repo.py \
  --organization "your-ado-org" \
  --project "your-ado-project" \
  --repository "contoso-finance-repo" \
  --branch "main"
```

**Step 3: Update Configuration**
Edit the generated YAML file to point to your new repository.
```yaml
git:
  repository: "contoso-finance-repo"
```

**Step 4: Deploy**
Run the deployment command.
```bash
make deploy config=config/projects/contoso_inc/finance_analytics.yaml env=dev
```

### 4. Docker-Based Workflow

You can run the entire workflow inside a Docker container to ensure a consistent environment.

**Step 1: Build the Docker Image**
```bash
make docker-build
```

**Step 2: Generate Project Configuration (in Docker)**
```bash
make docker-generate ARGS='"Contoso Inc" "Finance Analytics" --template basic_etl'
```

**Step 3: Initialize Azure DevOps Repository (in Docker)**
```bash
make docker-init-repo ARGS='--organization "your-ado-org" --project "your-ado-project" --repository "contoso-finance-repo" --branch "main"'
```

**Step 4: Deploy (in Docker)**
```bash
make docker-deploy config=config/projects/contoso_inc/finance_analytics.yaml env=dev ENVFILE=.env
```

### 5. Execute Deployment

> **Security Note:** The CLI automatically enforces mandatory security principals (Additional Admin/Contributor) on all workspaces by injecting them from your environment variables.

```bash
# Validate configuration syntax and structure
make validate config=config/projects/your_org/your_project.yaml

# Deploy to development environment
make deploy config=config/projects/your_org/your_project.yaml env=dev
```

## Utility Tools

The framework includes several utility scripts in `scripts/utilities/` to assist with setup and troubleshooting. These scripts automatically load credentials from your `.env` file.

### Initialize Azure DevOps Repository
Initializes an empty Azure DevOps repository with a `main` branch. This is required because Fabric Git integration fails if the target repository is completely empty (0 branches).

```bash
python scripts/utilities/init_ado_repo.py \
  --organization "your-org-name" \
  --project "your-project-name" \
  --repository "your-repo-name"
```

### Debug Azure DevOps Access
Verifies that your Service Principal has the correct permissions to access Azure DevOps.

```bash
python scripts/utilities/debug_ado_access.py \
  --organization "your-org-name" \
  --project "your-project-name"
```

### Debug Git Connection
Tests the connection to a Git repository using the configured credentials.

```bash
python scripts/utilities/debug_connection.py \
  --organization "your-org-name" \
  --project "your-project-name" \
  --repository "your-repo-name"
```

### List Workspace Items
Lists all items in a specified Fabric workspace to verify deployment.

```bash
python scripts/utilities/list_workspace_items.py --workspace "Workspace Name"
```

## Project Structure

```
src/
├── core/
│   ├── secrets.py         # 12-Factor App secret management with waterfall loading
│   ├── fabric_git_api.py  # REST API client for Git integration  
│   ├── templating.py      # Jinja2 artifact transformation engine
│   ├── config.py          # YAML configuration management
│   ├── fabric_wrapper.py  # Fabric CLI wrapper with version validation
│   ├── git_integration.py # Git synchronization
│   ├── audit.py          # Compliance audit logging
│   ├── telemetry.py      # Operational telemetry
│   ├── exceptions.py     # Exception hierarchy
│   └── cli.py            # Main deployment orchestrator (Entry Point)


config/
├── projects/
│   ├── ProductA/
│   │   └── sales_project.yaml
│   └── ProductB/
│       └── finance_project.yaml
└── environments/
    ├── dev.yaml
    ├── staging.yaml
    └── prod.yaml

templates/
└── blueprints/
    ├── basic_etl.yaml
    ├── advanced_analytics.yaml
    └── data_science.yaml

scripts/
├── bulk_destroy.py        # Bulk cleanup utility
├── generate_project.py    # Project scaffolding
├── preflight_check.py     # Environment validation
└── utilities/
    ├── analyze_migration.py   # Migration analysis tool
    ├── list_workspaces.py     # Workspace listing tool
    └── list_workspace_items.py # Item listing tool
```

## Total LOC: ~270 (vs original 1,830)

## Configuration Examples

See `templates/blueprints/` for organization-agnostic templates that can be customized for any project.

## Testing

```bash
# Run unit tests
pytest -m "not integration"

# Run integration tests (requires Fabric CLI + live token)
pytest tests/integration -m integration

# Full coverage
pytest --cov=src
```

## CI/CD Integration

GitHub Actions workflows included for:
- Automated testing
- Environment promotion (dev → staging → prod)
- Feature branch deployments
- Principal management

**Important:** For CI/CD pipelines to function, you must configure the required secrets (`AZURE_CLIENT_ID`, `AZURE_CLIENT_SECRET`, `AZURE_TENANT_ID`) in your GitHub repository settings. See [Usage Guide](docs/USAGE_GUIDE.md#troubleshooting) for details.

## Features

### Core Capabilities
- ✅ Workspace creation and management
- ✅ Folder structure (Bronze/Silver/Gold medallion) with item placement
- ✅ Item creation (Lakehouses, Warehouses, Notebooks, Pipelines)
- ✅ **Generic Resource Support** (Future-proof for any Fabric item type)
- ✅ Git integration (Azure DevOps & GitHub) and branch management
- ✅ Principal assignment and access control
- ✅ Idempotent deployments (rerun-safe)
- ✅ Comprehensive audit logging
- ✅ Multi-environment support
- ✅ Configuration validation

### Advanced Features
- ✅ Feature branch workflows
- ✅ Capacity management
- ✅ Template-based deployments
- ✅ Error diagnostics and remediation
- ✅ Progress tracking and reporting
- ✅ **Bulk Workspace Cleanup** utility

## Learnings Applied

This project incorporates key learnings from the original implementation:

1. **Build vs Buy Assessment** - Use official tools wherever possible
2. **Progressive Complexity** - Start simple, add features incrementally  
3. **Stakeholder Alignment** - Configuration-driven, easy to understand
4. **Maintenance Focus** - Minimal custom code, maximum leverage
5. **Evolution Strategy** - Built to adapt as Fabric CLI evolves

## Migration from Custom Solutions

If migrating from a custom Fabric API solution:

1. **Assessment** - Use `scripts/utilities/analyze_migration.py` to identify what can be replaced with CLI
2. **Migration** - Incremental replacement of custom components
3. **Validation** - Side-by-side testing during transition
4. **Deprecation** - Sunset plan for custom components

## Contributing

1. Follow the 270 LOC budget - justify any additions
2. Fabric CLI first - only add custom logic for genuine gaps
3. Configuration over code - make it reusable
4. Test thoroughly - both unit and integration tests
5. Document decisions - explain why custom code exists

## License

MIT License - Use freely in any organization.
