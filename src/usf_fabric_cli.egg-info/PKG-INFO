Metadata-Version: 2.4
Name: usf-fabric-cli
Version: 1.3.1
Summary: CLI tool for Microsoft Fabric CI/CD automation
Author-email: Sanmi Ibitoye <sanmi.ibitoye@leit.ltd>
License: MIT
Requires-Python: >=3.9
Description-Content-Type: text/markdown
Requires-Dist: typer>=0.9.0
Requires-Dist: rich>=13.0.0
Requires-Dist: pyyaml>=6.0
Requires-Dist: python-dotenv>=1.0.0
Requires-Dist: jsonschema>=4.19.0
Requires-Dist: azure-identity>=1.15.0
Requires-Dist: azure-keyvault-secrets>=4.7.0
Requires-Dist: requests>=2.31.0
Requires-Dist: gitpython>=3.1.0
Requires-Dist: azure-storage-blob>=12.19.0
Requires-Dist: pydantic>=2.5.0
Requires-Dist: pydantic-settings>=2.1.0
Requires-Dist: jinja2>=3.1.2
Requires-Dist: packaging>=23.0

# Fabric CLI CI/CD - Enterprise Deployment Framework

Enterprise-grade Microsoft Fabric deployment automation leveraging the official Fabric CLI with 12-Factor App configuration management, Jinja2 artifact templating, and REST API Git integration. Designed for organization-agnostic operation with 85% code reduction from traditional enterprise frameworks.

> **ðŸ”„ Lightweight Successor:** This project is the modern replacement for [usf-fabric-cicd](../usf-fabric-cicd), reducing complexity by 85% while maintaining enterprise capabilities through a thin wrapper architecture around the official Fabric CLI.

## Core Capabilities

- **Automated Deployment**: Idempotent workspace provisioning with intelligent state management
- **Secret Management**: 12-Factor App compliant credential handling (Environment Variables â†’ .env fallback â†’ Azure Key Vault)
- **Artifact Templating**: Jinja2 engine for environment-specific artifact transformation
- **Git Integration**: REST API-driven repository connections for Azure DevOps and GitHub
- **Audit Compliance**: Structured JSONL logging for regulatory requirements
- **Branch Isolation**: Feature branch workspaces for parallel development workflows  

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Configuration Layer              â”‚  (YAML-driven)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                     â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Fabric CLI     â”‚  â”‚ Thin Wrapper         â”‚
â”‚  (90% of work)  â”‚  â”‚ (~1,150 LOC wrapper) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Quick Start

### 1. Environment Setup

```bash
# Create and activate conda environment
conda env create -f environment.yml
conda activate fabric-cli-cicd

# Install dependencies and package in editable mode
make install

# Verify Fabric CLI installation and dependencies
python scripts/preflight_check.py --auto-install

# Configure authentication credentials
cp .env.template .env
# Edit .env with Service Principal credentials:
#   AZURE_CLIENT_ID       - Service Principal application ID
#   AZURE_CLIENT_SECRET   - Service Principal secret value
#   AZURE_TENANT_ID       - Azure AD tenant identifier
#   FABRIC_TOKEN          - Direct token (optional, auto-generated from SP)
#   AZURE_KEYVAULT_URL    - Azure Key Vault URL (optional, for production)

### 2. Azure DevOps Integration (Prerequisites)

If using Azure DevOps with a Service Principal, ensure the following:

1.  **Service Principal Access Level**: The Service Principal must have **Basic** access level in Azure DevOps Organization Settings -> Users.
2.  **Project Permissions**: The Service Principal must be added to the **Contributors** group of the target Azure DevOps Project.
3.  **Fabric Tenant Settings**: Enable "Service principals can use Fabric APIs" and "Service principals can create workspaces" in Fabric Admin Portal.
4.  **Workspace Admin**: The Service Principal must be assigned the **Admin** role in the workspace configuration (`project.yaml`).

### 3. Configure Your Project
```

### 3. End-to-End Workflow (From Scratch)

Follow these steps to deploy a new project from scratch:

**Step 1: Generate Project Configuration**
Use the template generator to create a standardized configuration file. Choose from **10 production-ready blueprints**:

```bash
# Standard ETL (Medallion architecture)
python scripts/generate_project.py "Contoso Inc" "Finance Analytics" --template basic_etl

# Real-time streaming (IoT, events, Eventstreams + KQL)
python scripts/generate_project.py "TechCorp" "IoT Platform" --template realtime_streaming

# Compliance-heavy (Healthcare, Finance, Government)
python scripts/generate_project.py "HealthCo" "Patient Platform" --template compliance_regulated

# See all 10 templates: docs/BLUEPRINT_CATALOG.md
# Output: config/projects/{org_name}/{project_name}.yaml
```

**Step 2: Initialize Azure DevOps Repository**
Create the backing Git repository for your new project.
```bash
python scripts/utilities/init_ado_repo.py \
  --organization "your-ado-org" \
  --project "your-ado-project" \
  --repository "contoso-finance-repo" \
  --branch "main"
```

**Step 3: Update Configuration**
Edit the generated YAML file to point to your new repository.
```yaml
git:
  repository: "contoso-finance-repo"
```

**Step 4: Deploy**
Run the deployment command.
```bash
make deploy config=config/projects/contoso_inc/finance_analytics.yaml env=dev
```

### 4. Docker-Based Workflow

You can run the entire workflow inside a Docker container to ensure a consistent environment.

**Step 1: Build the Docker Image**
```bash
make docker-build
```

**Step 2: Generate Project Configuration (in Docker)**
```bash
make docker-generate org="Contoso Inc" project="Finance Analytics" template=basic_etl
```

**Step 3: Initialize Azure DevOps Repository (in Docker)**
```bash
make docker-init-repo org="your-ado-org" project="your-ado-project" repo="contoso-finance-repo"
```

**Step 4: Deploy (in Docker)**
```bash
make docker-deploy config=config/projects/contoso_inc/finance_analytics.yaml env=dev ENVFILE=.env
```

### 5. Execute Deployment

> **Security Note:** The CLI automatically enforces mandatory security principals (Additional Admin/Contributor) on all workspaces by injecting them from your environment variables.

```bash
# Validate configuration syntax and structure
make validate config=config/projects/your_org/your_project.yaml

# Deploy to development environment
make deploy config=config/projects/your_org/your_project.yaml env=dev
```

## Make Targets Reference (21 Available)

### Local Development

| Target | Description | Example |
|--------|-------------|---------|
| `install` | Install dependencies in editable mode | `make install` |
| `build` | Build Python wheel package | `make build` |
| `test` | Run unit tests (no credentials) | `make test` |
| `test-integration` | Run integration tests (requires credentials) | `make test-integration` |
| `lint` | Format and lint code | `make lint` |
| `clean` | Remove cache files | `make clean` |

### Local Operations

| Target | Description | Example |
|--------|-------------|---------|
| `validate` | Validate config file syntax | `make validate config=path/to/config.yaml` |
| `diagnose` | Run pre-flight system checks | `make diagnose` |
| `deploy` | Deploy workspace from config | `make deploy config=path/to/config.yaml env=dev` |
| `destroy` | Destroy workspace from config | `make destroy config=path/to/config.yaml` |
| `bulk-destroy` | Bulk delete workspaces from list | `make bulk-destroy file=list.txt` |

### Docker Operations

All Docker targets accept `ENVFILE=.env.xxx` to specify which environment file to use (default: `.env`).

| Target | Description | Example |
|--------|-------------|---------|
| `docker-build` | Build Docker image | `make docker-build` |
| `docker-validate` | Validate config in container | `make docker-validate config=... ENVFILE=.env` |
| `docker-deploy` | Deploy workspace in container | `make docker-deploy config=... env=dev ENVFILE=.env` |
| `docker-destroy` | Destroy workspace in container | `make docker-destroy config=... ENVFILE=.env` |
| `docker-generate` | Generate project config in container | `make docker-generate org="Org" project="Proj" template=basic_etl` |
| `docker-init-repo` | Initialize ADO repo in container | `make docker-init-repo org="..." project="..." repo="..."` |
| `docker-shell` | Interactive shell in container | `make docker-shell ENVFILE=.env` |
| `docker-diagnose` | Run diagnostics in container | `make docker-diagnose ENVFILE=.env` |
| `docker-feature-deploy` | Deploy feature branch workspace | `make docker-feature-deploy config=... env=dev branch=feature/x` |

## CLI Flags Reference

### Deploy Command

```bash
python -m core.cli deploy CONFIG [OPTIONS]
```

| Flag | Short | Description |
|------|-------|-------------|
| `--env` | `-e` | Target environment (dev/staging/prod) |
| `--branch` | `-b` | Git branch to use for deployment |
| `--force-branch-workspace` | | Create isolated workspace for feature branch |
| `--validate-only` | | Validate config without deploying |
| `--diagnose` | | Run diagnostics before deployment |

### Destroy Command

```bash
python -m core.cli destroy CONFIG [OPTIONS]
```

| Flag | Short | Description |
|------|-------|-------------|
| `--env` | `-e` | Target environment (dev/staging/prod) |
| `--force` | `-f` | Skip confirmation prompt |

## Interactive Learning Guide

The project includes an **interactive web application** to help users understand and learn the CLI workflows:

```bash
cd webapp

# Option 1: Docker (Recommended)
./docker-quickstart.sh
# â†’ Open http://localhost:8080

# Option 2: Development mode (requires Python 3.11+ and Node.js 18+)
make install  # Install backend + frontend dependencies
make dev      # Start both servers (backend: 8001, frontend: 5173)
# â†’ Open http://localhost:5173
```

### Features
- **Visual Workflow Diagrams**: Interactive flowcharts showing deployment processes step-by-step
- **8 Comprehensive Scenarios**: Getting Started, Project Generation, Local/Docker Deployment, Feature Branches, Git Integration, Environment Promotion, Troubleshooting
- **Progress Tracking**: Track your learning progress through each guide
- **Code Snippets with Copy**: Easily copy commands and configurations

### Azure Deployment
Deploy the webapp to Azure Container Apps:
```bash
cd webapp
make deploy-azure        # Full deployment
make deploy-azure-dryrun # Preview what will be deployed
```

See [webapp/README.md](webapp/README.md) for detailed documentation.

## Utility Tools

The framework includes several utility scripts in `scripts/utilities/` to assist with setup and troubleshooting. These scripts automatically load credentials from your `.env` file.

### Initialize Azure DevOps Repository
Initializes an empty Azure DevOps repository with a `main` branch. This is required because Fabric Git integration fails if the target repository is completely empty (0 branches).

```bash
python scripts/utilities/init_ado_repo.py \
  --organization "your-org-name" \
  --project "your-project-name" \
  --repository "your-repo-name"
```

### Debug Azure DevOps Access
Verifies that your Service Principal has the correct permissions to access Azure DevOps.

```bash
python scripts/utilities/debug_ado_access.py \
  --organization "your-org-name" \
  --project "your-project-name"
```

### Debug Git Connection
Tests the connection to a Git repository using the configured credentials.

```bash
python scripts/utilities/debug_connection.py \
  --organization "your-org-name" \
  --project "your-project-name" \
  --repository "your-repo-name"
```

### List Workspace Items
Lists all items in a specified Fabric workspace to verify deployment.

```bash
python scripts/utilities/list_workspace_items.py --workspace "Workspace Name"
```

## Project Structure

```
src/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ secrets.py         # 12-Factor App secret management with waterfall loading
â”‚   â”œâ”€â”€ fabric_git_api.py  # REST API client for Git integration  
â”‚   â”œâ”€â”€ templating.py      # Jinja2 artifact transformation engine
â”‚   â”œâ”€â”€ config.py          # YAML configuration management
â”‚   â”œâ”€â”€ fabric_wrapper.py  # Fabric CLI wrapper with version validation
â”‚   â”œâ”€â”€ git_integration.py # Git synchronization
â”‚   â”œâ”€â”€ audit.py          # Compliance audit logging
â”‚   â”œâ”€â”€ telemetry.py      # Operational telemetry
â”‚   â”œâ”€â”€ exceptions.py     # Exception hierarchy
â”‚   â””â”€â”€ cli.py            # Main deployment orchestrator (Entry Point)


config/
â”œâ”€â”€ projects/              # Your organization configs
â”‚   â”œâ”€â”€ {org_name}/
â”‚   â”‚   â””â”€â”€ {project_name}.yaml
â”‚   â””â”€â”€ ...                # 7+ example orgs included
â””â”€â”€ environments/
    â”œâ”€â”€ dev.yaml
    â”œâ”€â”€ staging.yaml
    â”œâ”€â”€ test.yaml
    â””â”€â”€ prod.yaml

templates/
â””â”€â”€ blueprints/            # 10 production-ready templates
    â”œâ”€â”€ basic_etl.yaml
    â”œâ”€â”€ advanced_analytics.yaml
    â”œâ”€â”€ data_science.yaml
    â”œâ”€â”€ realtime_streaming.yaml
    â”œâ”€â”€ compliance_regulated.yaml
    â”œâ”€â”€ data_mesh_domain.yaml
    â”œâ”€â”€ migration_hybrid.yaml
    â”œâ”€â”€ minimal_starter.yaml
    â”œâ”€â”€ specialized_timeseries.yaml
    â””â”€â”€ extensive_example.yaml

scripts/
â”œâ”€â”€ bulk_destroy.py        # Bulk cleanup utility
â”œâ”€â”€ generate_project.py    # Project scaffolding
â”œâ”€â”€ preflight_check.py     # Environment validation
â””â”€â”€ utilities/
    â”œâ”€â”€ analyze_migration.py    # Migration analysis tool
    â”œâ”€â”€ debug_ado_access.py     # Azure DevOps permissions check
    â”œâ”€â”€ debug_connection.py     # Git connection testing
    â”œâ”€â”€ init_ado_repo.py        # Initialize ADO repository
    â”œâ”€â”€ list_workspaces.py      # Workspace listing tool
    â””â”€â”€ list_workspace_items.py # Item listing tool
```

## Total LOC: ~4,100 (thin wrapper architecture vs original monolithic 1,830)

## Configuration Examples

See `templates/blueprints/` for organization-agnostic templates that can be customized for any project.

## Testing

```bash
# Run unit tests
pytest -m "not integration"

# Run integration tests (requires Fabric CLI + live token)
pytest tests/integration -m integration

# Full coverage
pytest --cov=src
```

## CI/CD Integration

GitHub Actions workflows included for:
- Automated testing
- Environment promotion (dev â†’ staging â†’ prod)
- Feature branch deployments
- Principal management

**Important:** For CI/CD pipelines to function, you must configure the required secrets (`AZURE_CLIENT_ID`, `AZURE_CLIENT_SECRET`, `AZURE_TENANT_ID`) in your GitHub repository settings. See [Blueprint Catalog](docs/BLUEPRINT_CATALOG.md) for configuration examples.

## Features

### Core Capabilities
- âœ… Workspace creation and management
- âœ… Folder structure (Bronze/Silver/Gold medallion) with item placement
- âœ… Item creation (Lakehouses, Warehouses, Notebooks, Pipelines)
- âœ… **Generic Resource Support** (Future-proof for any Fabric item type)
- âœ… Git integration (Azure DevOps & GitHub) and branch management
- âœ… Principal assignment and access control
- âœ… Idempotent deployments (rerun-safe)
- âœ… Comprehensive audit logging
- âœ… Multi-environment support
- âœ… Configuration validation

### Advanced Features
- âœ… Feature branch workflows
- âœ… Capacity management
- âœ… Template-based deployments
- âœ… Error diagnostics and remediation
- âœ… Progress tracking and reporting
- âœ… **Bulk Workspace Cleanup** utility

## Learnings Applied

This project incorporates key learnings from the original implementation:

1. **Build vs Buy Assessment** - Use official tools wherever possible
2. **Progressive Complexity** - Start simple, add features incrementally  
3. **Stakeholder Alignment** - Configuration-driven, easy to understand
4. **Maintenance Focus** - Minimal custom code, maximum leverage
5. **Evolution Strategy** - Built to adapt as Fabric CLI evolves

## Migration from Custom Solutions

If migrating from a custom Fabric API solution:

1. **Assessment** - Use `scripts/utilities/analyze_migration.py` to identify what can be replaced with CLI
2. **Migration** - Incremental replacement of custom components
3. **Validation** - Side-by-side testing during transition
4. **Deprecation** - Sunset plan for custom components

## Contributing

1. Fabric CLI first - only add custom logic for genuine gaps
2. Configuration over code - make it reusable
3. Test thoroughly - both unit and integration tests
4. Document decisions - explain why custom code exists

## License

MIT License - Use freely in any organization.
